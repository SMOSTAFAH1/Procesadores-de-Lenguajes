P' -> { TSG = crearTS(); despTSG=0 } P { destruirTS(TSG) }
P -> B P  
P -> F P  
P -> eof  

S -> id Y 
	{ id.tipo = buscaTipoTS(id.pos);
	  if(id.tipo=null && Y.tipo=int) insertarTipoTS(id.pos, entero);//lexico
	  if(id.tipo=Y.tipo) S.tipo = ok;
	  else if(id.tipo=function)
			id.tipoParam = buscaTipoParam(id.pos);
			if(id.tipoParam = Y.tipo) S.tipo = ok;
			else S.tipo = error("");
	  else if(id.tipo=int && Y.tipo=null) S.tipo = ok;
	  else S.tipo = error;
	}
	
S -> id 
	{ id.tipo = buscaTipoTS(id.pos);
	  if(id.tipo = function) Y.tipoParam = buscaTipoParam(id.pos);
	  Y.tipo = id.tipo;
	} 
	Y

Y -> = E ;   
	{ if(Y.tipo != E.tipo) 
		error("A la variable se le debe asignar un valor del mismo tipo");
	}
	
Y -> ( L ) ;   
	{ if(Y.tipoParam != L.tipo)
		error("Llamada a funcion con parametros incorrectos");
	}
Y -> -- ; 
	{ if(Y.tipo != int)
		error("Solo se puede hacer postdecremento de un entero");
	}
	
S -> output E ;
	{ if(E.tipo == string || E.tipo == int ) S.tipo = tipo_ok 
	  else S.tipo = error("Solo se puede hacer output de enteros o cadenas")
	}
	
S -> input id ;
	{ id.tipo = buscaTipoTS(id.pos)
	  if( id.tipo == string || id.tipo == int) S.tipo=tipo_ok
	  else S.tipo = error("Solo se puede hacer input de cadenas o enteros")
	}
	
S -> return X ;
	{ if(S.tipoRet = null) S.tipo = error("Return no debe ir fuera de funcion);
	  else if(S.tipoRet = X.tipo) S.tipo = ok;
	  else S.tipo = error("Retorno de tipo incorrecto);
	}
	
X -> E
	{ X.tipo = E.tipo;
	}
	
X -> lambda 
	{ X.tipo = void;
	}
L -> E Q
	{ L.tipo = E.tipo x Q.tipo;
	}
	
L -> lambda
	{ L.tipo = null;
	}
	
Q -> , E Q1
	{ Q.tipo = E.tipo x Q1.tipo;
	}
	
Q -> lambda
	{ Q.tipo = null
	}
	
B -> if ( E ) S   
	{ if(E.tipo = boolean) B.tipo = S.tipo
	  else error("Condicion dentro del if debe de booleana);
	}
	
B -> while ( E ) { C }
	{ if(E.tipo = logico) B.tipo = C.tipo;
	  else B.tipo = error("Condicion del while debe ser logica");
	}
	
B -> {zonaDec = true}
	 var T id ;
	{ insertarTipoTS(id.pos, T.tipo);
	  insertarDespTS(id.pos, desp);
	  zonaDec = false;
	}
	
B -> { S.tipoRet = B.tipoRet }
	S
	{ B.tipo = S.tipo;
	}
	
F -> function H {zonaDec = true} id 
	{ TSL = crearTS(); TSactual = TSL;
	  insertarTipoTS(id.pos, funcion);
	  insertaEtTS(id.pos, etiqueta);
	  zonaDec = false;
	  despL = 0;
    }
	( A ) 
	{ insertarNumParam(id.pos, A.numParam);
      insertarTipoParam(id.pos, A.tipo);
      C.tipoRet = H.tipo 
    }
	{ C } 
	{
	}
	
H -> T 
	{ H.tipo = T.tipo;
	}
	
H -> void 
	{ H.tipo = void;
	}
	
A -> void
	{ A.tipo = void;
	}
	
A -> T { zonaDec = true } id K 
	{ insertarTipoTS(id.pos, T.tipo);
	  insertarDespTS(id.pos, desp);
	  desp = desp + T.ancho;
	  zonaDec = false;
	  A.numParam = 1 + K.numParam;
	  A.tipo = T.tipo x K.tipo;
	  zonaDec = false;
	}
		
K -> , T id K1
	{ zonaDec = true;
      insertarTipoTS(id.pos, T.tipo);
	  insertarDespTS(id.pos, desp);
	  desp = desp + T.ancho;
      zonaDec = false;
  
      K.tipo = T.tipo x K1.tipo
	  K.numParam = 1 + K1.numParam;
	}
	
K -> lambda
	{ K.tipo = null; //cadenaVacia
	}
	
C -> { B.tipoRet, C1.tipoRet = C.tipoRet }
	B C1 
	{ if(C.tipo = vacio) 
	}
	
C -> lambda

T -> int
T -> boolean
T -> string

E -> R G         
	{ if( G.tipo = vacio ) E.tipo = R.tipo;
	  else if( R.tipo = int && G.tipo = int ) E.tipo = boolean;
	}
	
G -> != R G1
	{ if( R.tipo = int && G1.tipo = int ) G.tipo = int;
      if( R.tipo = int && G1.tipo = vacio ) G.tipo = int;
	  else G.tipo = error("La operacion != solo se puede realizar en enteros");
	}
	
G -> lambda

R -> U O
	{ if(O.tipo = vacio) R.tipo = U.tipo;
	  else if(U.tipo, O.tipo = int) R.tipo = int;
	  else R.tipo = error("Tipos deben ser enteros en una suma");
	}
	
O -> + U O1
	{ if( U.tipo = int && O1.tipo = vacio ) O.tipo = int;
      else if( U.tipo = int && O1.tipo = int ) O.tipo = int;
	  else O.tipo = error("Tipos deben ser enteros");
	}
	
O -> lambda
	{ O.tipo = vacio }

U -> ! V       
	{ if(V.tipo = boolean) U.tipo = boolean 
	  else U.tipo = error("Debe se de tipo logico");
	}
	
U -> V
	{ U.tipo = V.tipo }

V -> id 
	{ id.tipo = buscaTipoTS(id.pos);
	  if(id.tipo = funcion) 
		Z.tipoParam = buscaTipoParam(id.pos);
	  Z.tipo = id.tipo;
	} 
	Z
	{ if(id.tipo = function) 
		V.tipo = buscaTipoRet(id.pos);
	  else V.tipo = id.tipo;
	}
	
V -> entero  
	{ V.tipo = int }

V -> cadena
	{ V.tipo = string }
	
V -> ( E )
	{ V.tipo = E.tipo }
	
Z -> ( L ) 
	{ if( Z.tipoParam != L.tipo )
		error("Llamada a funcion con parametros incorrectos");
	}
	
Z -> lambda 
	{}
	
Z -> --
	{ if( Z.tipo != int)
		error("Solo se puede hacer postdescremento de variables enteras");
	}